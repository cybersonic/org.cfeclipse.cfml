/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. C:/Program Files/Eclipse/workspace/CFELive/src/com/rohanclan/cfml/parser/cfscript\SPL.jj */
/*@egen*/
/*
 * Copyright \u00c2\u00a9 2002 Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * California 95054, U.S.A. All rights reserved.  Sun Microsystems, Inc. has
 * intellectual property rights relating to technology embodied in the product
 * that is described in this document. In particular, and without limitation,
 * these intellectual property rights may include one or more of the U.S.
 * patents listed at http://www.sun.com/patents and one or more additional
 * patents or pending patent applications in the U.S. and in other countries.
 * U.S. Government Rights - Commercial software. Government users are subject
 * to the Sun Microsystems, Inc. standard license agreement and applicable
 * provisions of the FAR and its supplements.  Use is subject to license terms.
 * Sun,  Sun Microsystems,  the Sun logo and  Java are trademarks or registered
 * trademarks of Sun Microsystems, Inc. in the U.S. and other countries.  This
 * product is covered and controlled by U.S. Export Control laws and may be
 * subject to the export or import laws in other countries.  Nuclear, missile,
 * chemical biological weapons or nuclear maritime end uses or end users,
 * whether direct or indirect, are strictly prohibited.  Export or reexport
 * to countries subject to U.S. embargo or to entities identified on U.S.
 * export exclusion lists, including, but not limited to, the denied persons
 * and specially designated nationals lists is strictly prohibited.
 */


options {                  
   STATIC = true;
   DEBUG_PARSER = false;
   OPTIMIZE_TOKEN_MANAGER = true;
   IGNORE_CASE = true;                    
}

PARSER_BEGIN(SPLParser)
package org.cfeclipse.cfml.parser.cfscript;
import java.io.*;
import java.util.List;
import java.util.ArrayList;

public class SPLParser/*@bgen(jjtree)*/implements SPLParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTSPLParserState jjtree = new JJTSPLParserState();

/*@egen*/

    private static List exceptions = new ArrayList();
    public Node getDocumentRoot() { return this.jjtree.rootNode(); }
    public List getExceptions() { return this.exceptions; }
    public void resetExceptions() { this.exceptions.clear(); }

    private static void error_skipto(int kind) {
        ParseException e = generateParseException();
        exceptions.add(new CFScriptErrorItem(e));
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != kind && t.kind != EOF);
    }

    public static void main(String[] args) throws ParseException, FileNotFoundException {
        SPLParser p = null;

        if (args.length < 1 ) {
            System.out.println("Reading from stdin") ;
            p = new SPLParser(System.in) ;
        } else {
            p = new SPLParser(new FileInputStream(args[0])) ;
        }

        SimpleNode node = p.CompilationUnit();
        node.dump("");

        List ex = p.getExceptions();
        if (ex.size() > 0) {
            java.util.Iterator i = ex.iterator();
            while (i.hasNext()) {
                System.out.println(((CFScriptErrorItem) i.next()).toString());
            }
        }
    }
}

PARSER_END(SPLParser)


SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN: /* keywords */
{
    <FUNCTION: "function">
    |
    <FOR: "for">
    |
    <WHILE: "while">
    |
    <DO: "do">
    |
    <VAR: "var">
    |
    <RETURN: "return">
    |
    <CONTINUE: "continue">
    |
    <BREAK: "break">
    |
    <SWITCH: "switch">
    |
    <CASE: "case">
    |
    <_DEFAULT: "default">
    |
    <TRY: "try">
    |
    <CATCH: "catch">
    |
    <OR: "or"> | <AND: "and">
    |
    <EQ: "eq"> | <NEQ: "neq">
    |
    <GT: "gt">	| <GTE: "gte"> | <GE: "ge">
    |
    <LT: "lt"> | <LTE: "lte"> | <LE: "le">

}

TOKEN : /* LITERALS */
{
    < INTEGER_LITERAL: ("-")? (<DIGIT>)+ >
|
    < STRING_LITERAL:
        "\"" (~["\""])* ( ("\"\"") (~["\""])* )* "\""  // single quoted strings
        |
        "'" (~["'"])* ( ("''") (~["'"])* )* "'"  // double quoted strings
    >
|
    < FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])+ >
}


/*
 * Program structuring syntax follows.
 */

ASTCompilationUnit CompilationUnit() :
{/*@bgen(jjtree) CompilationUnit */
   ASTCompilationUnit jjtn000 = new ASTCompilationUnit(JJTCOMPILATIONUNIT);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
/*@egen*/
   String name;
}
{/*@bgen(jjtree) CompilationUnit */
    try {
/*@egen*/
    (FunctionDeclaration() | VarDeclaration() | Statement())* <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ReturnStatement() :
{/*@bgen(jjtree) ReturnStatement */
  ASTReturnStatement jjtn000 = new ASTReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ReturnStatement */
    try {
/*@egen*/
    <RETURN> Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FunctionDeclaration()  :
{/*@bgen(jjtree) FunctionDeclaration */
  ASTFunctionDeclaration jjtn000 = new ASTFunctionDeclaration(JJTFUNCTIONDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) FunctionDeclaration */
    try {
/*@egen*/
    try {
        <FUNCTION> t = <IDENTIFIER> "(" (ParameterList())? ")" Statement()
        {
            jjtn000.name = t.image;
            jjtn000.aNodeToken = t;
        }
    } catch (ParseException e) {
        error_skipto(SEMICOLON);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VarDeclaration() :
{/*@bgen(jjtree) VarDeclaration */
  ASTVarDeclaration jjtn000 = new ASTVarDeclaration(JJTVARDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; String name;}
{/*@bgen(jjtree) VarDeclaration */
    try {
/*@egen*/
/*  <VAR> t = <IDENTIFIER> "=" Statement() ";" */
    try {
        <VAR> Assignment()
    } catch (ParseException e) {
        error_skipto(SEMICOLON);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

/*  { jjtThis.name = t.image; } */
}

/*
 * Expression syntax follows.
 */

void Expression()      :
{}
{
        LOOKAHEAD( PrimaryExpression() "=" )
        Assignment()
    |
        ConditionalOrExpression()
}

void Assignment()                : {/*@bgen(jjtree) #Assignment( 2) */
  ASTAssignment jjtn000 = new ASTAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #Assignment( 2) */
  try {
/*@egen*/
  PrimaryExpression() "="  Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  2);
    }
  }
/*@egen*/
}

void ConditionalOrExpression()       : {}
{
  ConditionalAndExpression()
  ( <OR>/*@bgen(jjtree) #OrNode( 2) */
         {
           ASTOrNode jjtn001 = new ASTOrNode(JJTORNODE);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
         }
         try {
/*@egen*/ ConditionalAndExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte001) {
           if (jjtc001) {
             jjtree.clearNodeScope(jjtn001);
             jjtc001 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte001 instanceof RuntimeException) {
             throw (RuntimeException)jjte001;
           }
           if (jjte001 instanceof ParseException) {
             throw (ParseException)jjte001;
           }
           throw (Error)jjte001;
         } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  2);
           }
         }
/*@egen*/ )*
}

void ConditionalAndExpression()       : {}
{
  InclusiveOrExpression()
  ( <AND>/*@bgen(jjtree) #AndNode( 2) */
          {
            ASTAndNode jjtn001 = new ASTAndNode(JJTANDNODE);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/ InclusiveOrExpression()/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
            }
          }
/*@egen*/ )*
}

void InclusiveOrExpression()       : {}
{
  ExclusiveOrExpression()
  ( "|"/*@bgen(jjtree) #BitwiseOrNode( 2) */
        {
          ASTBitwiseOrNode jjtn001 = new ASTBitwiseOrNode(JJTBITWISEORNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/ ExclusiveOrExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/ )*
}

void ExclusiveOrExpression()       : {}
{
  AndExpression()
  ( "^"/*@bgen(jjtree) #BitwiseXorNode( 2) */
        {
          ASTBitwiseXorNode jjtn001 = new ASTBitwiseXorNode(JJTBITWISEXORNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/ AndExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/ )*
}

void AndExpression()       : {}
{
  EqualityExpression()
  ( "&"/*@bgen(jjtree) #BitwiseAndNode( 2) */
        {
          ASTBitwiseAndNode jjtn001 = new ASTBitwiseAndNode(JJTBITWISEANDNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/ EqualityExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/ )*
}

void EqualityExpression()       : {}
{
  StrEQExpression()
  (
     <ISNOT>/*@bgen(jjtree) #NENode( 2) */
             {
               ASTNENode jjtn001 = new ASTNENode(JJTNENODE);
               boolean jjtc001 = true;
               jjtree.openNodeScope(jjtn001);
             }
             try {
/*@egen*/ RelationalExpression()/*@bgen(jjtree)*/
             } catch (Throwable jjte001) {
               if (jjtc001) {
                 jjtree.clearNodeScope(jjtn001);
                 jjtc001 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte001 instanceof RuntimeException) {
                 throw (RuntimeException)jjte001;
               }
               if (jjte001 instanceof ParseException) {
                 throw (ParseException)jjte001;
               }
               throw (Error)jjte001;
             } finally {
               if (jjtc001) {
                 jjtree.closeNodeScope(jjtn001,  2);
               }
             }
/*@egen*/
    |
     "is"/*@bgen(jjtree) #EQNode( 2) */
          {
            ASTEQNode jjtn002 = new ASTEQNode(JJTEQNODE);
            boolean jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
          }
          try {
/*@egen*/ RelationalExpression()/*@bgen(jjtree)*/
          } catch (Throwable jjte002) {
            if (jjtc002) {
              jjtree.clearNodeScope(jjtn002);
              jjtc002 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte002 instanceof RuntimeException) {
              throw (RuntimeException)jjte002;
            }
            if (jjte002 instanceof ParseException) {
              throw (ParseException)jjte002;
            }
            throw (Error)jjte002;
          } finally {
            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002,  2);
            }
          }
/*@egen*/
  )*
}

void StrEQExpression()       : {}
{
    RelationalExpression()
    (
            <EQ>/*@bgen(jjtree) #StrEQNode( 2) */
                 {
                   ASTStrEQNode jjtn001 = new ASTStrEQNode(JJTSTREQNODE);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
                 }
                 try {
/*@egen*/ RelationalExpression()/*@bgen(jjtree)*/
                 } catch (Throwable jjte001) {
                   if (jjtc001) {
                     jjtree.clearNodeScope(jjtn001);
                     jjtc001 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte001 instanceof RuntimeException) {
                     throw (RuntimeException)jjte001;
                   }
                   if (jjte001 instanceof ParseException) {
                     throw (ParseException)jjte001;
                   }
                   throw (Error)jjte001;
                 } finally {
                   if (jjtc001) {
                     jjtree.closeNodeScope(jjtn001,  2);
                   }
                 }
/*@egen*/
        |
            <NEQ>/*@bgen(jjtree) #StrNEQNode( 2) */
                  {
                    ASTStrNEQNode jjtn002 = new ASTStrNEQNode(JJTSTRNEQNODE);
                    boolean jjtc002 = true;
                    jjtree.openNodeScope(jjtn002);
                  }
                  try {
/*@egen*/ RelationalExpression()/*@bgen(jjtree)*/
                  } catch (Throwable jjte002) {
                    if (jjtc002) {
                      jjtree.clearNodeScope(jjtn002);
                      jjtc002 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte002 instanceof RuntimeException) {
                      throw (RuntimeException)jjte002;
                    }
                    if (jjte002 instanceof ParseException) {
                      throw (ParseException)jjte002;
                    }
                    throw (Error)jjte002;
                  } finally {
                    if (jjtc002) {
                      jjtree.closeNodeScope(jjtn002,  2);
                    }
                  }
/*@egen*/
    )*
}

void RelationalExpression()       : {}
{
  AdditiveExpression()
  (
    <LT>/*@bgen(jjtree) #LTNode( 2) */
         {
           ASTLTNode jjtn001 = new ASTLTNode(JJTLTNODE);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
         }
         try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte001) {
           if (jjtc001) {
             jjtree.clearNodeScope(jjtn001);
             jjtc001 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte001 instanceof RuntimeException) {
             throw (RuntimeException)jjte001;
           }
           if (jjte001 instanceof ParseException) {
             throw (ParseException)jjte001;
           }
           throw (Error)jjte001;
         } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  2);
           }
         }
/*@egen*/
   |
    <GT>/*@bgen(jjtree) #GTNode( 2) */
         {
           ASTGTNode jjtn002 = new ASTGTNode(JJTGTNODE);
           boolean jjtc002 = true;
           jjtree.openNodeScope(jjtn002);
         }
         try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte002) {
           if (jjtc002) {
             jjtree.clearNodeScope(jjtn002);
             jjtc002 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte002 instanceof RuntimeException) {
             throw (RuntimeException)jjte002;
           }
           if (jjte002 instanceof ParseException) {
             throw (ParseException)jjte002;
           }
           throw (Error)jjte002;
         } finally {
           if (jjtc002) {
             jjtree.closeNodeScope(jjtn002,  2);
           }
         }
/*@egen*/
   |
    (<LTE> | <LE>)/*@bgen(jjtree) #LENode( 2) */
                   {
                     ASTLENode jjtn003 = new ASTLENode(JJTLENODE);
                     boolean jjtc003 = true;
                     jjtree.openNodeScope(jjtn003);
                   }
                   try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                   } catch (Throwable jjte003) {
                     if (jjtc003) {
                       jjtree.clearNodeScope(jjtn003);
                       jjtc003 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte003 instanceof RuntimeException) {
                       throw (RuntimeException)jjte003;
                     }
                     if (jjte003 instanceof ParseException) {
                       throw (ParseException)jjte003;
                     }
                     throw (Error)jjte003;
                   } finally {
                     if (jjtc003) {
                       jjtree.closeNodeScope(jjtn003,  2);
                     }
                   }
/*@egen*/
   |
    (<GTE> | <GE>)/*@bgen(jjtree) #GENode( 2) */
                   {
                     ASTGENode jjtn004 = new ASTGENode(JJTGENODE);
                     boolean jjtc004 = true;
                     jjtree.openNodeScope(jjtn004);
                   }
                   try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                   } catch (Throwable jjte004) {
                     if (jjtc004) {
                       jjtree.clearNodeScope(jjtn004);
                       jjtc004 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte004 instanceof RuntimeException) {
                       throw (RuntimeException)jjte004;
                     }
                     if (jjte004 instanceof ParseException) {
                       throw (ParseException)jjte004;
                     }
                     throw (Error)jjte004;
                   } finally {
                     if (jjtc004) {
                       jjtree.closeNodeScope(jjtn004,  2);
                     }
                   }
/*@egen*/
  )*
}

// for future
void BinaryOp()       : {}
{
    <LE> | <LT> | <GE> | <GT> | <GTE> | <LTE> | "+" | "-" | "*" | "%" | "/" | "^" | "|" | "&"
}

void AdditiveExpression()       :
{}
{
  MultiplicativeExpression()
  (
    "+"/*@bgen(jjtree) #AddNode( 2) */
        {
          ASTAddNode jjtn001 = new ASTAddNode(JJTADDNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/
   |
    "-"/*@bgen(jjtree) #SubtractNode( 2) */
        {
          ASTSubtractNode jjtn002 = new ASTSubtractNode(JJTSUBTRACTNODE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/
  )*
}

void MultiplicativeExpression()       :
{}
{
  UnaryExpression()
  (
    "*"/*@bgen(jjtree) #MulNode( 2) */
         {
           ASTMulNode jjtn001 = new ASTMulNode(JJTMULNODE);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
         }
         try {
/*@egen*/  UnaryExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte001) {
           if (jjtc001) {
             jjtree.clearNodeScope(jjtn001);
             jjtc001 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte001 instanceof RuntimeException) {
             throw (RuntimeException)jjte001;
           }
           if (jjte001 instanceof ParseException) {
             throw (ParseException)jjte001;
           }
           throw (Error)jjte001;
         } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  2);
           }
         }
/*@egen*/
   |
    "/"/*@bgen(jjtree) #DivNode( 2) */
         {
           ASTDivNode jjtn002 = new ASTDivNode(JJTDIVNODE);
           boolean jjtc002 = true;
           jjtree.openNodeScope(jjtn002);
         }
         try {
/*@egen*/  UnaryExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte002) {
           if (jjtc002) {
             jjtree.clearNodeScope(jjtn002);
             jjtc002 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte002 instanceof RuntimeException) {
             throw (RuntimeException)jjte002;
           }
           if (jjte002 instanceof ParseException) {
             throw (ParseException)jjte002;
           }
           throw (Error)jjte002;
         } finally {
           if (jjtc002) {
             jjtree.closeNodeScope(jjtn002,  2);
           }
         }
/*@egen*/
   |
    "%"/*@bgen(jjtree) #ModNode( 2) */
         {
           ASTModNode jjtn003 = new ASTModNode(JJTMODNODE);
           boolean jjtc003 = true;
           jjtree.openNodeScope(jjtn003);
         }
         try {
/*@egen*/  UnaryExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte003) {
           if (jjtc003) {
             jjtree.clearNodeScope(jjtn003);
             jjtc003 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte003 instanceof RuntimeException) {
             throw (RuntimeException)jjte003;
           }
           if (jjte003 instanceof ParseException) {
             throw (ParseException)jjte003;
           }
           throw (Error)jjte003;
         } finally {
           if (jjtc003) {
             jjtree.closeNodeScope(jjtn003,  2);
           }
         }
/*@egen*/
  )*
}

void UnaryExpression()       :{}
{
        ("+" | "-") UnaryExpression()
     |
        PrimaryExpression()
}

void PrimaryExpression()       :
{ String name; }
{
        LOOKAHEAD(CFCMethodCall())
        CFCMethodCall()
    |
        LOOKAHEAD(2)
        StructRef()
    |
        LOOKAHEAD(2)
        FunctionCall()
    |
        Literal()
    |
        Id()
    |
        "(" Expression() ")"
}

void StructRef()                :
{/*@bgen(jjtree) StructRefNode */
  ASTStructRefNode jjtn000 = new ASTStructRefNode(JJTSTRUCTREFNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; String name;}
{/*@bgen(jjtree) StructRefNode */
    try {
/*@egen*/
    // <IDENTIFIER> "(" [ ParameterList() ] ")"
    t = <IDENTIFIER> ("." Id() | "[" Expression() "]")+/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { jjtn000.name = t.image; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void CFCMethodCall()                    :
{/*@bgen(jjtree) CFCMethodCallNode */
  ASTCFCMethodCallNode jjtn000 = new ASTCFCMethodCallNode(JJTCFCMETHODCALLNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; String name;}
{/*@bgen(jjtree) CFCMethodCallNode */
    try {
/*@egen*/
    t = <IDENTIFIER> "." FunctionCall()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { jjtn000.name = t.image; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


/* Think this is the def for variables */
void Id() :
{/*@bgen(jjtree) Id */
    ASTId jjtn000 = new ASTId(JJTID);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/   Token t;   }
{/*@bgen(jjtree) Id */
    try {
/*@egen*/
    t = <IDENTIFIER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { jjtn000.name = t.image; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void StringLiteral() :
{/*@bgen(jjtree) StringLiteral */
  ASTStringLiteral jjtn000 = new ASTStringLiteral(JJTSTRINGLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) StringLiteral */
    try {
/*@egen*/
    t = <STRING_LITERAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.val = t.image;
        jjtn000.aNodeToken = getToken(0);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void IntLiteral() :
{/*@bgen(jjtree) IntLiteral */
  ASTIntLiteral jjtn000 = new ASTIntLiteral(JJTINTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) IntLiteral */
    try {
/*@egen*/
    t = <INTEGER_LITERAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.val = t.image;
        jjtn000.aNodeToken = getToken(0);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FloatingPointLiteral():
{/*@bgen(jjtree) FloatingPointLiteral */
  ASTFloatingPointLiteral jjtn000 = new ASTFloatingPointLiteral(JJTFLOATINGPOINTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) FloatingPointLiteral */
    try {
/*@egen*/
    t = <FLOATING_POINT_LITERAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {   jjtn000.val = t.image;
        jjtn000.aNodeToken = getToken(0);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Literal()       : { }
{
    StringLiteral()	| IntLiteral() | BooleanLiteral() | FloatingPointLiteral()
}

void BooleanLiteral()       : { }
{/*@bgen(jjtree) TrueNode */
    {
      ASTTrueNode jjtn001 = new ASTTrueNode(JJTTRUENODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    "true"/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/ |/*@bgen(jjtree) FalseNode */
                       {
                         ASTFalseNode jjtn002 = new ASTFalseNode(JJTFALSENODE);
                         boolean jjtc002 = true;
                         jjtree.openNodeScope(jjtn002);
                       }
                       try {
/*@egen*/ "false"/*@bgen(jjtree)*/
                       } finally {
                         if (jjtc002) {
                           jjtree.closeNodeScope(jjtn002, true);
                         }
                       }
/*@egen*/
}

/*
 * Statement syntax follows.
 */

void Statement()       : { }
{
    try {
        <SEMICOLON>
    |
        LOOKAHEAD(2)
        FunctionCall()
    |
        Block()
    | (
    /* TODO: The below LOOKAHEAD uses very poor syntax - it should really be expanded out
             to the tokens in CFCMethodCall(). But we'll leave it for the moment as it aids
             readability and maintainability
    */
            LOOKAHEAD(CFCMethodCall())
            CFCMethodCall()
        |
            StatementExpression()

    )
    |
        ReturnStatement()
    |
        IfStatement()
    |
        WhileStatement()
    |
        (LOOKAHEAD(4) ForInStatement() | ForStatement())
    |
        DoStatement()
    |
        ContinueStatement()
    |
        BreakStatement()
    |
        SwitchStatement()
    |
        TryStatement()

    } catch (ParseException e) {
        error_skipto(SEMICOLON);
    }

}

void ExpressionList()       :
{}
{
    [Expression()] ("," Expression())*
}

void ForInStatement() :
{/*@bgen(jjtree) ForInStatement */
  ASTForInStatement jjtn000 = new ASTForInStatement(JJTFORINSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForInStatement */
    try {
/*@egen*/
    <FOR> "(" Id() "in" Expression() ")" Statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ForStatement()                   :
{/*@bgen(jjtree) ForStatementNode */
  ASTForStatementNode jjtn000 = new ASTForStatementNode(JJTFORSTATEMENTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForStatementNode */
    try {
/*@egen*/
    <FOR> "(" ExpressionList() <SEMICOLON> [ Expression() ] <SEMICOLON> ExpressionList() ")"
        Statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FunctionCall()                   :
{/*@bgen(jjtree) FunctionCallNode */
  ASTFunctionCallNode jjtn000 = new ASTFunctionCallNode(JJTFUNCTIONCALLNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ String name; Token t;}
{/*@bgen(jjtree) FunctionCallNode */
    try {
/*@egen*/
    t = <IDENTIFIER> "(" [ ParameterList() ] ")"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.name = t.image;
        jjtn000.aNodeToken = t;

    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ParameterList()  :
{/*@bgen(jjtree) ParameterList */
  ASTParameterList jjtn000 = new ASTParameterList(JJTPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  }
{/*@bgen(jjtree) ParameterList */
    try {
/*@egen*/
    Expression() ("," Expression())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Block() :
{/*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Block */
  try {
/*@egen*/ "{" ( Statement() )* "}"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ }

void StatementExpression() :
/*
 * The last expansion of this production accepts more than the legal
 * SPL expansions for StatementExpression.
 */
{/*@bgen(jjtree) StatementExpression */
  ASTStatementExpression jjtn000 = new ASTStatementExpression(JJTSTATEMENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StatementExpression */
  try {
/*@egen*/ Assignment() <SEMICOLON>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ }

void IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{/*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStatement */
        try {
/*@egen*/	"if" "(" Expression() ")" Statement() [ LOOKAHEAD(1) "else" Statement() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	}

void WhileStatement() :
{/*@bgen(jjtree) WhileStatement */
  ASTWhileStatement jjtn000 = new ASTWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileStatement */
        try {
/*@egen*/	<WHILE> "(" Expression() ")" Statement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	}


void DoStatement() :
{/*@bgen(jjtree) DoStatement */
  ASTDoStatement jjtn000 = new ASTDoStatement(JJTDOSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DoStatement */
    try {
/*@egen*/
    <DO> Block() <WHILE> "(" Expression() ")" <SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
switch (expression) {
  case constant: [case constant:]... statement(s) break;
  [case constant: [case constant:]... statement(s) break;]...
  [default: statement(s)] }
- 'constant' must be really a constant: It can't be a variable, a function
  or any other expression.
- break  statement into case blocks is not required, so this production will
  not consider it
- The default statement is not required
- The default statement does not have to follow all the case statements
*/
void SwitchStatement(): {/*@bgen(jjtree) SwitchStatement */
  ASTSwitchStatement jjtn000 = new ASTSwitchStatement(JJTSWITCHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SwitchStatement */
    try {
/*@egen*/
    <SWITCH> "(" Expression() ")"
    "{"
        ( SwitchLabel() (Statement())* )*
    "}"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SwitchLabel(): {/*@bgen(jjtree) SwitchLabel */
  ASTSwitchLabel jjtn000 = new ASTSwitchLabel(JJTSWITCHLABEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SwitchLabel */
  try {
/*@egen*/
  <CASE> Literal() ":" |  <_DEFAULT> ":"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void TryStatement() : {/*@bgen(jjtree) TryStatement */
  ASTTryStatement jjtn000 = new ASTTryStatement(JJTTRYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TryStatement */
  try {
/*@egen*/
  <TRY> Block()
  ( <CATCH> "(" Id() Id() ")" Block() )+/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ContinueStatement()      : {} { <CONTINUE> <SEMICOLON> }
void BreakStatement()      : {} { <BREAK> <SEMICOLON> }

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: (<LETTER>|"_") (<LETTER>|<DIGIT>|"_")* >
|
  < #LETTER: [ "a"-"z", "A"-"Z" ] >
|
  < #DIGIT: [ "0"-"9"] >
|
  <ISNOT: "is not">
|
  <SEMICOLON: ";" >
}
